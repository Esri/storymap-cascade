{"version":3,"sources":["../src/lib/functions.js","../src/lib/callbacks.js","../src/lib/embed.js","../src/lib/postmessage.js","../src/lib/compatibility-check.js","../node_modules/es6-collections/index.js","../node_modules/native-promise-only/lib/npo.src.js","../src/player.js"],"names":["getMethodName","prop","type","indexOf","toLowerCase","substr","toUpperCase","isDomElement","element","window","HTMLElement","isInteger","value","isNaN","parseFloat","isFinite","Math","floor","isVimeoUrl","url","test","getVimeoUrl","oEmbedParameters","arguments","length","undefined","id","idOrUrl","Error","replace","TypeError","storeCallback","player","name","callback","playerCallbacks","callbackMap","get","push","set","getCallbacks","removeCallback","index","splice","shiftCallbacks","shift","swapCallbacks","oldElement","newElement","delete","getOEmbedParameters","defaults","reduce","params","param","getAttribute","createEmbed","_ref","html","querySelector","div","document","createElement","innerHTML","appendChild","firstChild","setAttribute","getOEmbedData","videoUrl","Promise","resolve","reject","encodeURIComponent","location","hostname","hasOwnProperty","xhr","XDomainRequest","XMLHttpRequest","open","onload","status","json","JSON","parse","responseText","domain_status_code","error","onerror","send","parseMessageData","data","postMessage","method","contentWindow","message","ieVersion","navigator","userAgent","stringify","origin","processData","callbacks","event","forEach","promise","call","e","isNode","global","toString","arrayIndexOfSupport","Array","prototype","postMessageSupport","exports","createCollection","proto","objectOnly","Collection","a","this","constructor","_keys","_values","_itp","init","sharedSize","add","sharedDelete","key","has","i","p","sharedGet","list","Object","is","setHas","mapHas","sharedSet","sharedAdd","sharedClear","sharedKeys","sharedIterator","sharedValues","mapEntries","setEntries","itp","array","array2","done","v","k","sharedForEach","context","it","entries","r","next","defineProperty","b","WeakMap","Map","values","Set","WeakSet","definition","module","schedule","fn","self","cycle","timer","scheduling_queue","drain","isThenable","o","_then","o_type","_typeof","then","notify","chain","state","success","failure","notifyIsolated","cb","ret","msg","err","triggered","def","def_wrapper","MakeDefWrapper","apply","iteratePromises","Constructor","arr","resolver","rejecter","idx","MakeDef","executor","__NPO__","builtInProp","ToString","setImmediate","setTimeout","obj","val","config","Item","first","last","item","f","PromisePrototype","len","msgs","count","playerMap","readyMap","Player","options","jQuery","console","warn","getElementById","nodeName","iframe","readyPromise","onMessage","_this","source","isReadyEvent","isPingResponse","addEventListener","attachEvent","_originalElement","catch","args","_this2","ready","_this3","_this4","eventName","callMethod","time","language","kind","_this5","removeAttribute","remove","autopause","color","currentTime","loop","playbackRate","volume","Vimeo","parent","elements","slice","querySelectorAll","handleError","iframes","space","parentElement","style","paddingBottom","bottom"],"mappings":"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","file":"dist/player.min.js","sourcesContent":["/**\n * @module lib/functions\n */\n\n/**\n * Check to see this is a node environment.\n * @type {Boolean}\n */\n/* global global */\nexport const isNode = typeof global !== 'undefined' &&\n  ({}).toString.call(global) === '[object global]';\n\n/**\n * Get the name of the method for a given getter or setter.\n *\n * @param {string} prop The name of the property.\n * @param {string} type Either “get” or “set”.\n * @return {string}\n */\nexport function getMethodName(prop, type) {\n    if (prop.indexOf(type.toLowerCase()) === 0) {\n        return prop;\n    }\n\n    return `${type.toLowerCase()}${prop.substr(0, 1).toUpperCase()}${prop.substr(1)}`;\n}\n\n/**\n * Check to see if the object is a DOM Element.\n *\n * @param {*} element The object to check.\n * @return {boolean}\n */\nexport function isDomElement(element) {\n    return element instanceof window.HTMLElement;\n}\n\n/**\n * Check to see whether the value is a number.\n *\n * @see http://dl.dropboxusercontent.com/u/35146/js/tests/isNumber.html\n * @param {*} value The value to check.\n * @param {boolean} integer Check if the value is an integer.\n * @return {boolean}\n */\nexport function isInteger(value) {\n    // eslint-disable-next-line eqeqeq\n    return !isNaN(parseFloat(value)) && isFinite(value) && Math.floor(value) == value;\n}\n\n/**\n * Check to see if the URL is a Vimeo url.\n *\n * @param {string} url The url string.\n * @return {boolean}\n */\nexport function isVimeoUrl(url) {\n    return (/^(https?:)?\\/\\/((player|www).)?vimeo.com(?=$|\\/)/).test(url);\n}\n\n/**\n * Get the Vimeo URL from an element.\n * The element must have either a data-vimeo-id or data-vimeo-url attribute.\n *\n * @param {object} oEmbedParameters The oEmbed parameters.\n * @return {string}\n */\nexport function getVimeoUrl(oEmbedParameters = {}) {\n    const id = oEmbedParameters.id;\n    const url = oEmbedParameters.url;\n    const idOrUrl = id || url;\n\n    if (!idOrUrl) {\n        throw new Error('An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.');\n    }\n\n    if (isInteger(idOrUrl)) {\n        return `https://vimeo.com/${idOrUrl}`;\n    }\n\n    if (isVimeoUrl(idOrUrl)) {\n        return idOrUrl.replace('http:', 'https:');\n    }\n\n    if (id) {\n        throw new TypeError(`“${id}” is not a valid video id.`);\n    }\n\n    throw new TypeError(`“${idOrUrl}” is not a vimeo.com url.`);\n}\n","/**\n * @module lib/callbacks\n */\n\nexport const callbackMap = new WeakMap();\n\n/**\n * Store a callback for a method or event for a player.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @param {(function(this:Player, *): void|{resolve: function, reject: function})} callback\n *        The callback to call or an object with resolve and reject functions for a promise.\n * @return {void}\n */\nexport function storeCallback(player, name, callback) {\n    const playerCallbacks = callbackMap.get(player.element) || {};\n\n    if (!(name in playerCallbacks)) {\n        playerCallbacks[name] = [];\n    }\n\n    playerCallbacks[name].push(callback);\n    callbackMap.set(player.element, playerCallbacks);\n}\n\n/**\n * Get the callbacks for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @return {function[]}\n */\nexport function getCallbacks(player, name) {\n    const playerCallbacks = callbackMap.get(player.element) || {};\n    return playerCallbacks[name] || [];\n}\n\n/**\n * Remove a stored callback for a method or event for a player.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @param {function} [callback] The specific callback to remove.\n * @return {boolean} Was this the last callback?\n */\nexport function removeCallback(player, name, callback) {\n    const playerCallbacks = callbackMap.get(player.element) || {};\n\n    if (!playerCallbacks[name]) {\n        return true;\n    }\n\n    // If no callback is passed, remove all callbacks for the event\n    if (!callback) {\n        playerCallbacks[name] = [];\n        callbackMap.set(player.element, playerCallbacks);\n\n        return true;\n    }\n\n    const index = playerCallbacks[name].indexOf(callback);\n\n    if (index !== -1) {\n        playerCallbacks[name].splice(index, 1);\n    }\n\n    callbackMap.set(player.element, playerCallbacks);\n    return playerCallbacks[name] && playerCallbacks[name].length === 0;\n}\n\n/**\n * Return the first stored callback for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @return {function} The callback, or false if there were none\n */\nexport function shiftCallbacks(player, name) {\n    const playerCallbacks = getCallbacks(player, name);\n\n    if (playerCallbacks.length < 1) {\n        return false;\n    }\n\n    const callback = playerCallbacks.shift();\n    removeCallback(player, name, callback);\n    return callback;\n}\n\n/**\n * Move callbacks associated with an element to another element.\n *\n * @param {HTMLElement} oldElement The old element.\n * @param {HTMLElement} newElement The new element.\n * @return {void}\n */\nexport function swapCallbacks(oldElement, newElement) {\n    const playerCallbacks = callbackMap.get(oldElement);\n\n    callbackMap.set(newElement, playerCallbacks);\n    callbackMap.delete(oldElement);\n}\n","/**\n * @module lib/embed\n */\n\nimport { isVimeoUrl, getVimeoUrl } from './functions';\n\nconst oEmbedParameters = [\n    'autopause',\n    'autoplay',\n    'background',\n    'byline',\n    'color',\n    'height',\n    'id',\n    'loop',\n    'maxheight',\n    'maxwidth',\n    'muted',\n    'playsinline',\n    'portrait',\n    'responsive',\n    'speed',\n    'title',\n    'transparent',\n    'url',\n    'width'\n];\n\n/**\n * Get the 'data-vimeo'-prefixed attributes from an element as an object.\n *\n * @param {HTMLElement} element The element.\n * @param {Object} [defaults={}] The default values to use.\n * @return {Object<string, string>}\n */\nexport function getOEmbedParameters(element, defaults = {}) {\n    return oEmbedParameters.reduce((params, param) => {\n        const value = element.getAttribute(`data-vimeo-${param}`);\n\n        if (value || value === '') {\n            params[param] = value === '' ? 1 : value;\n        }\n\n        return params;\n    }, defaults);\n}\n\n/**\n * Create an embed from oEmbed data inside an element.\n *\n * @param {object} data The oEmbed data.\n * @param {HTMLElement} element The element to put the iframe in.\n * @return {HTMLIFrameElement} The iframe embed.\n */\nexport function createEmbed({ html }, element) {\n    if (!element) {\n        throw new TypeError('An element must be provided');\n    }\n\n    if (element.getAttribute('data-vimeo-initialized') !== null) {\n        return element.querySelector('iframe');\n    }\n\n    const div = document.createElement('div');\n    div.innerHTML = html;\n\n    element.appendChild(div.firstChild);\n    element.setAttribute('data-vimeo-initialized', 'true');\n\n    return element.querySelector('iframe');\n}\n\n/**\n * Make an oEmbed call for the specified URL.\n *\n * @param {string} videoUrl The vimeo.com url for the video.\n * @param {Object} [params] Parameters to pass to oEmbed.\n * @param {HTMLElement} element The element.\n * @return {Promise}\n */\nexport function getOEmbedData(videoUrl, params = {}, element) {\n    return new Promise((resolve, reject) => {\n        if (!isVimeoUrl(videoUrl)) {\n            throw new TypeError(`“${videoUrl}” is not a vimeo.com url.`);\n        }\n\n        let url = `https://vimeo.com/api/oembed.json?url=${encodeURIComponent(videoUrl)}&domain=${window.location.hostname}`;\n\n        for (const param in params) {\n            if (params.hasOwnProperty(param)) {\n                url += `&${param}=${encodeURIComponent(params[param])}`;\n            }\n        }\n\n        const xhr = 'XDomainRequest' in window ? new XDomainRequest() : new XMLHttpRequest();\n        xhr.open('GET', url, true);\n\n        xhr.onload = function() {\n            if (xhr.status === 404) {\n                reject(new Error(`“${videoUrl}” was not found.`));\n                return;\n            }\n\n            if (xhr.status === 403) {\n                reject(new Error(`“${videoUrl}” is not embeddable.`));\n                return;\n            }\n\n            try {\n                const json = JSON.parse(xhr.responseText);\n                // Check api response for 403 on oembed\n                if (json.domain_status_code === 403) {\n                    // We still want to create the embed to give users visual feedback\n                    createEmbed(json, element);\n                    reject(new Error(`“${videoUrl}” is not embeddable.`));\n                    return;\n                }\n\n                resolve(json);\n            }\n            catch (error) {\n                reject(error);\n            }\n        };\n\n        xhr.onerror = function() {\n            const status = xhr.status ? ` (${xhr.status})` : '';\n            reject(new Error(`There was an error fetching the embed code from Vimeo${status}.`));\n        };\n\n        xhr.send();\n    });\n}\n\n/**\n * Initialize all embeds within a specific element\n *\n * @param {HTMLElement} [parent=document] The parent element.\n * @return {void}\n */\nexport function initializeEmbeds(parent = document) {\n    const elements = [].slice.call(parent.querySelectorAll('[data-vimeo-id], [data-vimeo-url]'));\n\n    const handleError = (error) => {\n        if ('console' in window && console.error) {\n            console.error(`There was an error creating an embed: ${error}`);\n        }\n    };\n\n    elements.forEach((element) => {\n        try {\n            // Skip any that have data-vimeo-defer\n            if (element.getAttribute('data-vimeo-defer') !== null) {\n                return;\n            }\n\n            const params = getOEmbedParameters(element);\n            const url = getVimeoUrl(params);\n\n            getOEmbedData(url, params, element).then((data) => {\n                return createEmbed(data, element);\n            }).catch(handleError);\n        }\n        catch (error) {\n            handleError(error);\n        }\n    });\n}\n\n/**\n * Resize embeds when messaged by the player.\n *\n * @param {HTMLElement} [parent=document] The parent element.\n * @return {void}\n */\nexport function resizeEmbeds(parent = document) {\n    const onMessage = (event) => {\n        if (!isVimeoUrl(event.origin)) {\n            return;\n        }\n\n        // 'spacechange' is fired only on embeds with cards\n        if (!event.data || event.data.event !== 'spacechange') {\n            return;\n        }\n\n        const iframes = parent.querySelectorAll('iframe');\n\n        for (let i = 0; i < iframes.length; i++) {\n            if (iframes[i].contentWindow !== event.source) {\n                continue;\n            }\n\n            // Change padding-bottom of the enclosing div to accommodate\n            // card carousel without distorting aspect ratio\n            const space = iframes[i].parentElement;\n            space.style.paddingBottom = `${event.data.data[0].bottom}px`;\n\n            break;\n        }\n    };\n\n    if (window.addEventListener) {\n        window.addEventListener('message', onMessage, false);\n    }\n    else if (window.attachEvent) {\n        window.attachEvent('onmessage', onMessage);\n    }\n}\n","/**\n * @module lib/postmessage\n */\n\nimport { getCallbacks, removeCallback, shiftCallbacks } from './callbacks';\n\n/**\n * Parse a message received from postMessage.\n *\n * @param {*} data The data received from postMessage.\n * @return {object}\n */\nexport function parseMessageData(data) {\n    if (typeof data === 'string') {\n        data = JSON.parse(data);\n    }\n\n    return data;\n}\n\n/**\n * Post a message to the specified target.\n *\n * @param {Player} player The player object to use.\n * @param {string} method The API method to call.\n * @param {object} params The parameters to send to the player.\n * @return {void}\n */\nexport function postMessage(player, method, params) {\n    if (!player.element.contentWindow || !player.element.contentWindow.postMessage) {\n        return;\n    }\n\n    let message = {\n        method\n    };\n\n    if (params !== undefined) {\n        message.value = params;\n    }\n\n    // IE 8 and 9 do not support passing messages, so stringify them\n    const ieVersion = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\\d+).*$/, '$1'));\n    if (ieVersion >= 8 && ieVersion < 10) {\n        message = JSON.stringify(message);\n    }\n\n    player.element.contentWindow.postMessage(message, player.origin);\n}\n\n/**\n * Parse the data received from a message event.\n *\n * @param {Player} player The player that received the message.\n * @param {(Object|string)} data The message data. Strings will be parsed into JSON.\n * @return {void}\n */\nexport function processData(player, data) {\n    data = parseMessageData(data);\n    let callbacks = [];\n    let param;\n\n    if (data.event) {\n        if (data.event === 'error') {\n            const promises = getCallbacks(player, data.data.method);\n\n            promises.forEach((promise) => {\n                const error = new Error(data.data.message);\n                error.name = data.data.name;\n\n                promise.reject(error);\n                removeCallback(player, data.data.method, promise);\n            });\n        }\n\n        callbacks = getCallbacks(player, `event:${data.event}`);\n        param = data.data;\n    }\n    else if (data.method) {\n        const callback = shiftCallbacks(player, data.method);\n\n        if (callback) {\n            callbacks.push(callback);\n            param = data.value;\n        }\n    }\n\n    callbacks.forEach((callback) => {\n        try {\n            if (typeof callback === 'function') {\n                callback.call(player, param);\n                return;\n            }\n\n            callback.resolve(param);\n        }\n        catch (e) {\n            // empty\n        }\n    });\n}\n","import { isNode } from './functions';\n\nconst arrayIndexOfSupport = typeof Array.prototype.indexOf !== 'undefined';\nconst postMessageSupport = typeof window !== 'undefined' && typeof window.postMessage !== 'undefined';\n\nif (!isNode && (!arrayIndexOfSupport || !postMessageSupport)) {\n    throw new Error('Sorry, the Vimeo Player API is not available in this browser.');\n}\n","(function (exports) {'use strict';\n  //shared pointer\n  var i;\n  //shortcuts\n  var defineProperty = Object.defineProperty, is = function(a,b) { return (a === b) || (a !== a && b !== b) };\n\n\n  //Polyfill global objects\n  if (typeof WeakMap == 'undefined') {\n    exports.WeakMap = createCollection({\n      // WeakMap#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // WeakMap#clear():\n      clear: sharedClear,\n      // WeakMap#get(key:void*):void*\n      get: sharedGet,\n      // WeakMap#has(key:void*):boolean\n      has: mapHas,\n      // WeakMap#set(key:void*, value:void*):void\n      set: sharedSet\n    }, true);\n  }\n\n  if (typeof Map == 'undefined' || typeof ((new Map).values) !== 'function' || !(new Map).values().next) {\n    exports.Map = createCollection({\n      // WeakMap#delete(key:void*):boolean\n      'delete': sharedDelete,\n      //:was Map#get(key:void*[, d3fault:void*]):void*\n      // Map#has(key:void*):boolean\n      has: mapHas,\n      // Map#get(key:void*):boolean\n      get: sharedGet,\n      // Map#set(key:void*, value:void*):void\n      set: sharedSet,\n      // Map#keys(void):Iterator\n      keys: sharedKeys,\n      // Map#values(void):Iterator\n      values: sharedValues,\n      // Map#entries(void):Iterator\n      entries: mapEntries,\n      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n      forEach: sharedForEach,\n      // Map#clear():\n      clear: sharedClear\n    });\n  }\n\n  if (typeof Set == 'undefined' || typeof ((new Set).values) !== 'function' || !(new Set).values().next) {\n    exports.Set = createCollection({\n      // Set#has(value:void*):boolean\n      has: setHas,\n      // Set#add(value:void*):boolean\n      add: sharedAdd,\n      // Set#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // Set#clear():\n      clear: sharedClear,\n      // Set#keys(void):Iterator\n      keys: sharedValues, // specs actually say \"the same function object as the initial value of the values property\"\n      // Set#values(void):Iterator\n      values: sharedValues,\n      // Set#entries(void):Iterator\n      entries: setEntries,\n      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs\n      forEach: sharedForEach\n    });\n  }\n\n  if (typeof WeakSet == 'undefined') {\n    exports.WeakSet = createCollection({\n      // WeakSet#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // WeakSet#add(value:void*):boolean\n      add: sharedAdd,\n      // WeakSet#clear():\n      clear: sharedClear,\n      // WeakSet#has(value:void*):boolean\n      has: setHas\n    }, true);\n  }\n\n\n  /**\n   * ES6 collection constructor\n   * @return {Function} a collection class\n   */\n  function createCollection(proto, objectOnly){\n    function Collection(a){\n      if (!this || this.constructor !== Collection) return new Collection(a);\n      this._keys = [];\n      this._values = [];\n      this._itp = []; // iteration pointers\n      this.objectOnly = objectOnly;\n\n      //parse initial iterable argument passed\n      if (a) init.call(this, a);\n    }\n\n    //define size for non object-only collections\n    if (!objectOnly) {\n      defineProperty(proto, 'size', {\n        get: sharedSize\n      });\n    }\n\n    //set prototype\n    proto.constructor = Collection;\n    Collection.prototype = proto;\n\n    return Collection;\n  }\n\n\n  /** parse initial iterable argument passed */\n  function init(a){\n    var i;\n    //init Set argument, like `[1,2,3,{}]`\n    if (this.add)\n      a.forEach(this.add, this);\n    //init Map argument like `[[1,2], [{}, 4]]`\n    else\n      a.forEach(function(a){this.set(a[0],a[1])}, this);\n  }\n\n\n  /** delete */\n  function sharedDelete(key) {\n    if (this.has(key)) {\n      this._keys.splice(i, 1);\n      this._values.splice(i, 1);\n      // update iteration pointers\n      this._itp.forEach(function(p) { if (i < p[0]) p[0]--; });\n    }\n    // Aurora here does it while Canary doesn't\n    return -1 < i;\n  };\n\n  function sharedGet(key) {\n    return this.has(key) ? this._values[i] : undefined;\n  }\n\n  function has(list, key) {\n    if (this.objectOnly && key !== Object(key))\n      throw new TypeError(\"Invalid value used as weak collection key\");\n    //NaN or 0 passed\n    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);){}\n    else i = list.indexOf(key);\n    return -1 < i;\n  }\n\n  function setHas(value) {\n    return has.call(this, this._values, value);\n  }\n\n  function mapHas(value) {\n    return has.call(this, this._keys, value);\n  }\n\n  /** @chainable */\n  function sharedSet(key, value) {\n    this.has(key) ?\n      this._values[i] = value\n      :\n      this._values[this._keys.push(key) - 1] = value\n    ;\n    return this;\n  }\n\n  /** @chainable */\n  function sharedAdd(value) {\n    if (!this.has(value)) this._values.push(value);\n    return this;\n  }\n\n  function sharedClear() {\n    (this._keys || 0).length =\n    this._values.length = 0;\n  }\n\n  /** keys, values, and iterate related methods */\n  function sharedKeys() {\n    return sharedIterator(this._itp, this._keys);\n  }\n\n  function sharedValues() {\n    return sharedIterator(this._itp, this._values);\n  }\n\n  function mapEntries() {\n    return sharedIterator(this._itp, this._keys, this._values);\n  }\n\n  function setEntries() {\n    return sharedIterator(this._itp, this._values, this._values);\n  }\n\n  function sharedIterator(itp, array, array2) {\n    var p = [0], done = false;\n    itp.push(p);\n    return {\n      next: function() {\n        var v, k = p[0];\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]]: array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n        return { done: done, value: v };\n      }\n    };\n  }\n\n  function sharedSize() {\n    return this._values.length;\n  }\n\n  function sharedForEach(callback, context) {\n    var it = this.entries();\n    for (;;) {\n      var r = it.next();\n      if (r.done) break;\n      callback.call(context, r.value[1], r.value[0], this);\n    }\n  }\n\n})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window );\n","/*! Native Promise Only\n    v0.8.1 (c) Kyle Simpson\n    MIT License: http://getify.mit-license.org\n*/\n\n(function UMD(name,context,definition){\n\t// special form of UMD for polyfilling across evironments\n\tcontext[name] = context[name] || definition();\n\tif (typeof module != \"undefined\" && module.exports) { module.exports = context[name]; }\n\telse if (typeof define == \"function\" && define.amd) { define(function $AMD$(){ return context[name]; }); }\n})(\"Promise\",typeof global != \"undefined\" ? global : this,function DEF(){\n\t/*jshint validthis:true */\n\t\"use strict\";\n\n\tvar builtInProp, cycle, scheduling_queue,\n\t\tToString = Object.prototype.toString,\n\t\ttimer = (typeof setImmediate != \"undefined\") ?\n\t\t\tfunction timer(fn) { return setImmediate(fn); } :\n\t\t\tsetTimeout\n\t;\n\n\t// dammit, IE8.\n\ttry {\n\t\tObject.defineProperty({},\"x\",{});\n\t\tbuiltInProp = function builtInProp(obj,name,val,config) {\n\t\t\treturn Object.defineProperty(obj,name,{\n\t\t\t\tvalue: val,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: config !== false\n\t\t\t});\n\t\t};\n\t}\n\tcatch (err) {\n\t\tbuiltInProp = function builtInProp(obj,name,val) {\n\t\t\tobj[name] = val;\n\t\t\treturn obj;\n\t\t};\n\t}\n\n\t// Note: using a queue instead of array for efficiency\n\tscheduling_queue = (function Queue() {\n\t\tvar first, last, item;\n\n\t\tfunction Item(fn,self) {\n\t\t\tthis.fn = fn;\n\t\t\tthis.self = self;\n\t\t\tthis.next = void 0;\n\t\t}\n\n\t\treturn {\n\t\t\tadd: function add(fn,self) {\n\t\t\t\titem = new Item(fn,self);\n\t\t\t\tif (last) {\n\t\t\t\t\tlast.next = item;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst = item;\n\t\t\t\t}\n\t\t\t\tlast = item;\n\t\t\t\titem = void 0;\n\t\t\t},\n\t\t\tdrain: function drain() {\n\t\t\t\tvar f = first;\n\t\t\t\tfirst = last = cycle = void 0;\n\n\t\t\t\twhile (f) {\n\t\t\t\t\tf.fn.call(f.self);\n\t\t\t\t\tf = f.next;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t})();\n\n\tfunction schedule(fn,self) {\n\t\tscheduling_queue.add(fn,self);\n\t\tif (!cycle) {\n\t\t\tcycle = timer(scheduling_queue.drain);\n\t\t}\n\t}\n\n\t// promise duck typing\n\tfunction isThenable(o) {\n\t\tvar _then, o_type = typeof o;\n\n\t\tif (o != null &&\n\t\t\t(\n\t\t\t\to_type == \"object\" || o_type == \"function\"\n\t\t\t)\n\t\t) {\n\t\t\t_then = o.then;\n\t\t}\n\t\treturn typeof _then == \"function\" ? _then : false;\n\t}\n\n\tfunction notify() {\n\t\tfor (var i=0; i<this.chain.length; i++) {\n\t\t\tnotifyIsolated(\n\t\t\t\tthis,\n\t\t\t\t(this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n\t\t\t\tthis.chain[i]\n\t\t\t);\n\t\t}\n\t\tthis.chain.length = 0;\n\t}\n\n\t// NOTE: This is a separate function to isolate\n\t// the `try..catch` so that other code can be\n\t// optimized better\n\tfunction notifyIsolated(self,cb,chain) {\n\t\tvar ret, _then;\n\t\ttry {\n\t\t\tif (cb === false) {\n\t\t\t\tchain.reject(self.msg);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (cb === true) {\n\t\t\t\t\tret = self.msg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = cb.call(void 0,self.msg);\n\t\t\t\t}\n\n\t\t\t\tif (ret === chain.promise) {\n\t\t\t\t\tchain.reject(TypeError(\"Promise-chain cycle\"));\n\t\t\t\t}\n\t\t\t\telse if (_then = isThenable(ret)) {\n\t\t\t\t\t_then.call(ret,chain.resolve,chain.reject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchain.resolve(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tchain.reject(err);\n\t\t}\n\t}\n\n\tfunction resolve(msg) {\n\t\tvar _then, self = this;\n\n\t\t// already triggered?\n\t\tif (self.triggered) { return; }\n\n\t\tself.triggered = true;\n\n\t\t// unwrap\n\t\tif (self.def) {\n\t\t\tself = self.def;\n\t\t}\n\n\t\ttry {\n\t\t\tif (_then = isThenable(msg)) {\n\t\t\t\tschedule(function(){\n\t\t\t\t\tvar def_wrapper = new MakeDefWrapper(self);\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_then.call(msg,\n\t\t\t\t\t\t\tfunction $resolve$(){ resolve.apply(def_wrapper,arguments); },\n\t\t\t\t\t\t\tfunction $reject$(){ reject.apply(def_wrapper,arguments); }\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\treject.call(def_wrapper,err);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\telse {\n\t\t\t\tself.msg = msg;\n\t\t\t\tself.state = 1;\n\t\t\t\tif (self.chain.length > 0) {\n\t\t\t\t\tschedule(notify,self);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\treject.call(new MakeDefWrapper(self),err);\n\t\t}\n\t}\n\n\tfunction reject(msg) {\n\t\tvar self = this;\n\n\t\t// already triggered?\n\t\tif (self.triggered) { return; }\n\n\t\tself.triggered = true;\n\n\t\t// unwrap\n\t\tif (self.def) {\n\t\t\tself = self.def;\n\t\t}\n\n\t\tself.msg = msg;\n\t\tself.state = 2;\n\t\tif (self.chain.length > 0) {\n\t\t\tschedule(notify,self);\n\t\t}\n\t}\n\n\tfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n\t\tfor (var idx=0; idx<arr.length; idx++) {\n\t\t\t(function IIFE(idx){\n\t\t\t\tConstructor.resolve(arr[idx])\n\t\t\t\t.then(\n\t\t\t\t\tfunction $resolver$(msg){\n\t\t\t\t\t\tresolver(idx,msg);\n\t\t\t\t\t},\n\t\t\t\t\trejecter\n\t\t\t\t);\n\t\t\t})(idx);\n\t\t}\n\t}\n\n\tfunction MakeDefWrapper(self) {\n\t\tthis.def = self;\n\t\tthis.triggered = false;\n\t}\n\n\tfunction MakeDef(self) {\n\t\tthis.promise = self;\n\t\tthis.state = 0;\n\t\tthis.triggered = false;\n\t\tthis.chain = [];\n\t\tthis.msg = void 0;\n\t}\n\n\tfunction Promise(executor) {\n\t\tif (typeof executor != \"function\") {\n\t\t\tthrow TypeError(\"Not a function\");\n\t\t}\n\n\t\tif (this.__NPO__ !== 0) {\n\t\t\tthrow TypeError(\"Not a promise\");\n\t\t}\n\n\t\t// instance shadowing the inherited \"brand\"\n\t\t// to signal an already \"initialized\" promise\n\t\tthis.__NPO__ = 1;\n\n\t\tvar def = new MakeDef(this);\n\n\t\tthis[\"then\"] = function then(success,failure) {\n\t\t\tvar o = {\n\t\t\t\tsuccess: typeof success == \"function\" ? success : true,\n\t\t\t\tfailure: typeof failure == \"function\" ? failure : false\n\t\t\t};\n\t\t\t// Note: `then(..)` itself can be borrowed to be used against\n\t\t\t// a different promise constructor for making the chained promise,\n\t\t\t// by substituting a different `this` binding.\n\t\t\to.promise = new this.constructor(function extractChain(resolve,reject) {\n\t\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t\t}\n\n\t\t\t\to.resolve = resolve;\n\t\t\t\to.reject = reject;\n\t\t\t});\n\t\t\tdef.chain.push(o);\n\n\t\t\tif (def.state !== 0) {\n\t\t\t\tschedule(notify,def);\n\t\t\t}\n\n\t\t\treturn o.promise;\n\t\t};\n\t\tthis[\"catch\"] = function $catch$(failure) {\n\t\t\treturn this.then(void 0,failure);\n\t\t};\n\n\t\ttry {\n\t\t\texecutor.call(\n\t\t\t\tvoid 0,\n\t\t\t\tfunction publicResolve(msg){\n\t\t\t\t\tresolve.call(def,msg);\n\t\t\t\t},\n\t\t\t\tfunction publicReject(msg) {\n\t\t\t\t\treject.call(def,msg);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tcatch (err) {\n\t\t\treject.call(def,err);\n\t\t}\n\t}\n\n\tvar PromisePrototype = builtInProp({},\"constructor\",Promise,\n\t\t/*configurable=*/false\n\t);\n\n\t// Note: Android 4 cannot use `Object.defineProperty(..)` here\n\tPromise.prototype = PromisePrototype;\n\n\t// built-in \"brand\" to signal an \"uninitialized\" promise\n\tbuiltInProp(PromisePrototype,\"__NPO__\",0,\n\t\t/*configurable=*/false\n\t);\n\n\tbuiltInProp(Promise,\"resolve\",function Promise$resolve(msg) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\t// note: best \"isPromise\" check that's practical for now\n\t\tif (msg && typeof msg == \"object\" && msg.__NPO__ === 1) {\n\t\t\treturn msg;\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\tresolve(msg);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"reject\",function Promise$reject(msg) {\n\t\treturn new this(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\treject(msg);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"all\",function Promise$all(arr) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\tif (ToString.call(arr) != \"[object Array]\") {\n\t\t\treturn Constructor.reject(TypeError(\"Not an array\"));\n\t\t}\n\t\tif (arr.length === 0) {\n\t\t\treturn Constructor.resolve([]);\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\tvar len = arr.length, msgs = Array(len), count = 0;\n\n\t\t\titeratePromises(Constructor,arr,function resolver(idx,msg) {\n\t\t\t\tmsgs[idx] = msg;\n\t\t\t\tif (++count === len) {\n\t\t\t\t\tresolve(msgs);\n\t\t\t\t}\n\t\t\t},reject);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"race\",function Promise$race(arr) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\tif (ToString.call(arr) != \"[object Array]\") {\n\t\t\treturn Constructor.reject(TypeError(\"Not an array\"));\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\titeratePromises(Constructor,arr,function resolver(idx,msg){\n\t\t\t\tresolve(msg);\n\t\t\t},reject);\n\t\t});\n\t});\n\n\treturn Promise;\n});\n","import './lib/compatibility-check';\n\nimport 'es6-collections';\nimport Promise from 'native-promise-only';\n\nimport { storeCallback, getCallbacks, removeCallback, swapCallbacks } from './lib/callbacks';\nimport { getMethodName, isDomElement, isVimeoUrl, getVimeoUrl, isNode } from './lib/functions';\nimport { getOEmbedParameters, getOEmbedData, createEmbed, initializeEmbeds, resizeEmbeds } from './lib/embed';\nimport { parseMessageData, postMessage, processData } from './lib/postmessage';\n\nconst playerMap = new WeakMap();\nconst readyMap = new WeakMap();\n\nclass Player {\n     /**\n     * Create a Player.\n     *\n     * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element A reference to the Vimeo\n     *        player iframe, and id, or a jQuery object.\n     * @param {object} [options] oEmbed parameters to use when creating an embed in the element.\n     * @return {Player}\n     */\n    constructor(element, options = {}) {\n        /* global jQuery */\n        if (window.jQuery && element instanceof jQuery) {\n            if (element.length > 1 && window.console && console.warn) {\n                console.warn('A jQuery object with multiple elements was passed, using the first element.');\n            }\n\n            element = element[0];\n        }\n\n        // Find an element by ID\n        if (typeof document !== 'undefined' && typeof element === 'string') {\n            element = document.getElementById(element);\n        }\n\n        // Not an element!\n        if (!isDomElement(element)) {\n            throw new TypeError('You must pass either a valid element or a valid id.');\n        }\n\n        // Already initialized an embed in this div, so grab the iframe\n        if (element.nodeName !== 'IFRAME') {\n            const iframe = element.querySelector('iframe');\n\n            if (iframe) {\n                element = iframe;\n            }\n        }\n\n        // iframe url is not a Vimeo url\n        if (element.nodeName === 'IFRAME' && !isVimeoUrl(element.getAttribute('src') || '')) {\n            throw new Error('The player element passed isn’t a Vimeo embed.');\n        }\n\n        // If there is already a player object in the map, return that\n        if (playerMap.has(element)) {\n            return playerMap.get(element);\n        }\n\n        this.element = element;\n        this.origin = '*';\n\n        const readyPromise = new Promise((resolve, reject) => {\n            const onMessage = (event) => {\n                if (!isVimeoUrl(event.origin) || this.element.contentWindow !== event.source) {\n                    return;\n                }\n\n                if (this.origin === '*') {\n                    this.origin = event.origin;\n                }\n\n                const data = parseMessageData(event.data);\n                const isReadyEvent = 'event' in data && data.event === 'ready';\n                const isPingResponse = 'method' in data && data.method === 'ping';\n\n                if (isReadyEvent || isPingResponse) {\n                    this.element.setAttribute('data-ready', 'true');\n                    resolve();\n                    return;\n                }\n\n                processData(this, data);\n            };\n\n            if (window.addEventListener) {\n                window.addEventListener('message', onMessage, false);\n            }\n            else if (window.attachEvent) {\n                window.attachEvent('onmessage', onMessage);\n            }\n\n            if (this.element.nodeName !== 'IFRAME') {\n                const params = getOEmbedParameters(element, options);\n                const url = getVimeoUrl(params);\n\n                getOEmbedData(url, params, element).then((data) => {\n                    const iframe = createEmbed(data, element);\n                    // Overwrite element with the new iframe,\n                    // but store reference to the original element\n                    this.element = iframe;\n                    this._originalElement = element;\n\n                    swapCallbacks(element, iframe);\n                    playerMap.set(this.element, this);\n\n                    return data;\n                }).catch((error) => reject(error));\n            }\n        });\n\n        // Store a copy of this Player in the map\n        readyMap.set(this, readyPromise);\n        playerMap.set(this.element, this);\n\n        // Send a ping to the iframe so the ready promise will be resolved if\n        // the player is already ready.\n        if (this.element.nodeName === 'IFRAME') {\n            postMessage(this, 'ping');\n        }\n\n        return this;\n    }\n\n    /**\n     * Get a promise for a method.\n     *\n     * @param {string} name The API method to call.\n     * @param {Object} [args={}] Arguments to send via postMessage.\n     * @return {Promise}\n     */\n    callMethod(name, args = {}) {\n        return new Promise((resolve, reject) => {\n            // We are storing the resolve/reject handlers to call later, so we\n            // can’t return here.\n            // eslint-disable-next-line promise/always-return\n            return this.ready().then(() => {\n                storeCallback(this, name, {\n                    resolve,\n                    reject\n                });\n\n                postMessage(this, name, args);\n            }).catch((error) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * Get a promise for the value of a player property.\n     *\n     * @param {string} name The property name\n     * @return {Promise}\n     */\n    get(name) {\n        return new Promise((resolve, reject) => {\n            name = getMethodName(name, 'get');\n\n            // We are storing the resolve/reject handlers to call later, so we\n            // can’t return here.\n            // eslint-disable-next-line promise/always-return\n            return this.ready().then(() => {\n                storeCallback(this, name, {\n                    resolve,\n                    reject\n                });\n\n                postMessage(this, name);\n            });\n        });\n    }\n\n    /**\n     * Get a promise for setting the value of a player property.\n     *\n     * @param {string} name The API method to call.\n     * @param {mixed} value The value to set.\n     * @return {Promise}\n     */\n    set(name, value) {\n        return Promise.resolve(value).then((val) => {\n            name = getMethodName(name, 'set');\n\n            if (val === undefined || val === null) {\n                throw new TypeError('There must be a value to set.');\n            }\n\n            return this.ready().then(() => {\n                return new Promise((resolve, reject) => {\n                    storeCallback(this, name, {\n                        resolve,\n                        reject\n                    });\n\n                    postMessage(this, name, val);\n                });\n            });\n        });\n    }\n\n    /**\n     * Add an event listener for the specified event. Will call the\n     * callback with a single parameter, `data`, that contains the data for\n     * that event.\n     *\n     * @param {string} eventName The name of the event.\n     * @param {function(*)} callback The function to call when the event fires.\n     * @return {void}\n     */\n    on(eventName, callback) {\n        if (!eventName) {\n            throw new TypeError('You must pass an event name.');\n        }\n\n        if (!callback) {\n            throw new TypeError('You must pass a callback function.');\n        }\n\n        if (typeof callback !== 'function') {\n            throw new TypeError('The callback must be a function.');\n        }\n\n        const callbacks = getCallbacks(this, `event:${eventName}`);\n        if (callbacks.length === 0) {\n            this.callMethod('addEventListener', eventName).catch(() => {\n                // Ignore the error. There will be an error event fired that\n                // will trigger the error callback if they are listening.\n            });\n        }\n\n        storeCallback(this, `event:${eventName}`, callback);\n    }\n\n    /**\n     * Remove an event listener for the specified event. Will remove all\n     * listeners for that event if a `callback` isn’t passed, or only that\n     * specific callback if it is passed.\n     *\n     * @param {string} eventName The name of the event.\n     * @param {function} [callback] The specific callback to remove.\n     * @return {void}\n     */\n    off(eventName, callback) {\n        if (!eventName) {\n            throw new TypeError('You must pass an event name.');\n        }\n\n        if (callback && typeof callback !== 'function') {\n            throw new TypeError('The callback must be a function.');\n        }\n\n        const lastCallback = removeCallback(this, `event:${eventName}`, callback);\n\n        // If there are no callbacks left, remove the listener\n        if (lastCallback) {\n            this.callMethod('removeEventListener', eventName).catch((e) => {\n                // Ignore the error. There will be an error event fired that\n                // will trigger the error callback if they are listening.\n            });\n        }\n    }\n\n    /**\n     * A promise to load a new video.\n     *\n     * @promise LoadVideoPromise\n     * @fulfill {number} The video with this id successfully loaded.\n     * @reject {TypeError} The id was not a number.\n     */\n    /**\n     * Load a new video into this embed. The promise will be resolved if\n     * the video is successfully loaded, or it will be rejected if it could\n     * not be loaded.\n     *\n     * @param {number} id The id of the video.\n     * @return {LoadVideoPromise}\n     */\n    loadVideo(id) {\n        return this.callMethod('loadVideo', id);\n    }\n\n    /**\n     * A promise to perform an action when the Player is ready.\n     *\n     * @todo document errors\n     * @promise LoadVideoPromise\n     * @fulfill {void}\n     */\n    /**\n     * Trigger a function when the player iframe has initialized. You do not\n     * need to wait for `ready` to trigger to begin adding event listeners\n     * or calling other methods.\n     *\n     * @return {ReadyPromise}\n     */\n    ready() {\n        const readyPromise = readyMap.get(this) || new Promise((resolve, reject) => {\n            reject('Unknown player. Probably unloaded.');\n        });\n        return Promise.resolve(readyPromise);\n    }\n\n    /**\n     * A promise to add a cue point to the player.\n     *\n     * @promise AddCuePointPromise\n     * @fulfill {string} The id of the cue point to use for removeCuePoint.\n     * @reject {RangeError} the time was less than 0 or greater than the\n     *         video’s duration.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Add a cue point to the player.\n     *\n     * @param {number} time The time for the cue point.\n     * @param {object} [data] Arbitrary data to be returned with the cue point.\n     * @return {AddCuePointPromise}\n     */\n    addCuePoint(time, data = {}) {\n        return this.callMethod('addCuePoint', { time, data });\n    }\n\n    /**\n     * A promise to remove a cue point from the player.\n     *\n     * @promise AddCuePointPromise\n     * @fulfill {string} The id of the cue point that was removed.\n     * @reject {InvalidCuePoint} The cue point with the specified id was not\n     *         found.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Remove a cue point from the video.\n     *\n     * @param {string} id The id of the cue point to remove.\n     * @return {RemoveCuePointPromise}\n     */\n    removeCuePoint(id) {\n        return this.callMethod('removeCuePoint', id);\n    }\n\n    /**\n     * A representation of a text track on a video.\n     *\n     * @typedef {Object} VimeoTextTrack\n     * @property {string} language The ISO language code.\n     * @property {string} kind The kind of track it is (captions or subtitles).\n     * @property {string} label The human‐readable label for the track.\n     */\n    /**\n     * A promise to enable a text track.\n     *\n     * @promise EnableTextTrackPromise\n     * @fulfill {VimeoTextTrack} The text track that was enabled.\n     * @reject {InvalidTrackLanguageError} No track was available with the\n     *         specified language.\n     * @reject {InvalidTrackError} No track was available with the specified\n     *         language and kind.\n     */\n    /**\n     * Enable the text track with the specified language, and optionally the\n     * specified kind (captions or subtitles).\n     *\n     * When set via the API, the track language will not change the viewer’s\n     * stored preference.\n     *\n     * @param {string} language The two‐letter language code.\n     * @param {string} [kind] The kind of track to enable (captions or subtitles).\n     * @return {EnableTextTrackPromise}\n     */\n    enableTextTrack(language, kind) {\n        if (!language) {\n            throw new TypeError('You must pass a language.');\n        }\n\n        return this.callMethod('enableTextTrack', {\n            language,\n            kind\n        });\n    }\n\n    /**\n     * A promise to disable the active text track.\n     *\n     * @promise DisableTextTrackPromise\n     * @fulfill {void} The track was disabled.\n     */\n    /**\n     * Disable the currently-active text track.\n     *\n     * @return {DisableTextTrackPromise}\n     */\n    disableTextTrack() {\n        return this.callMethod('disableTextTrack');\n    }\n\n    /**\n     * A promise to pause the video.\n     *\n     * @promise PausePromise\n     * @fulfill {void} The video was paused.\n     */\n    /**\n     * Pause the video if it’s playing.\n     *\n     * @return {PausePromise}\n     */\n    pause() {\n        return this.callMethod('pause');\n    }\n\n    /**\n     * A promise to play the video.\n     *\n     * @promise PlayPromise\n     * @fulfill {void} The video was played.\n     */\n    /**\n     * Play the video if it’s paused. **Note:** on iOS and some other\n     * mobile devices, you cannot programmatically trigger play. Once the\n     * viewer has tapped on the play button in the player, however, you\n     * will be able to use this function.\n     *\n     * @return {PlayPromise}\n     */\n    play() {\n        return this.callMethod('play');\n    }\n\n    /**\n     * A promise to unload the video.\n     *\n     * @promise UnloadPromise\n     * @fulfill {void} The video was unloaded.\n     */\n    /**\n     * Return the player to its initial state.\n     *\n     * @return {UnloadPromise}\n     */\n    unload() {\n        return this.callMethod('unload');\n    }\n\n    /**\n     * Cleanup the player and remove it from the DOM\n     *\n     * It won't be usable and a new one should be constructed\n     *  in order to do any operations.\n     *\n     * @return {Promise}\n     */\n    destroy() {\n        return new Promise((resolve) => {\n            readyMap.delete(this);\n            playerMap.delete(this.element);\n            if (this._originalElement) {\n                playerMap.delete(this._originalElement);\n                this._originalElement.removeAttribute('data-vimeo-initialized');\n            }\n            if (this.element && this.element.nodeName === 'IFRAME') {\n                this.element.remove();\n            }\n            resolve();\n        });\n    }\n\n    /**\n     * A promise to get the autopause behavior of the video.\n     *\n     * @promise GetAutopausePromise\n     * @fulfill {boolean} Whether autopause is turned on or off.\n     * @reject {UnsupportedError} Autopause is not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Get the autopause behavior for this player.\n     *\n     * @return {GetAutopausePromise}\n     */\n    getAutopause() {\n        return this.get('autopause');\n    }\n\n    /**\n     * A promise to set the autopause behavior of the video.\n     *\n     * @promise SetAutopausePromise\n     * @fulfill {boolean} Whether autopause is turned on or off.\n     * @reject {UnsupportedError} Autopause is not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Enable or disable the autopause behavior of this player.\n     *\n     * By default, when another video is played in the same browser, this\n     * player will automatically pause. Unless you have a specific reason\n     * for doing so, we recommend that you leave autopause set to the\n     * default (`true`).\n     *\n     * @param {boolean} autopause\n     * @return {SetAutopausePromise}\n     */\n    setAutopause(autopause) {\n        return this.set('autopause', autopause);\n    }\n\n    /**\n     * A promise to get the color of the player.\n     *\n     * @promise GetColorPromise\n     * @fulfill {string} The hex color of the player.\n     */\n    /**\n     * Get the color for this player.\n     *\n     * @return {GetColorPromise}\n     */\n    getColor() {\n        return this.get('color');\n    }\n\n    /**\n     * A promise to set the color of the player.\n     *\n     * @promise SetColorPromise\n     * @fulfill {string} The color was successfully set.\n     * @reject {TypeError} The string was not a valid hex or rgb color.\n     * @reject {ContrastError} The color was set, but the contrast is\n     *         outside of the acceptable range.\n     * @reject {EmbedSettingsError} The owner of the player has chosen to\n     *         use a specific color.\n     */\n    /**\n     * Set the color of this player to a hex or rgb string. Setting the\n     * color may fail if the owner of the video has set their embed\n     * preferences to force a specific color.\n     *\n     * @param {string} color The hex or rgb color string to set.\n     * @return {SetColorPromise}\n     */\n    setColor(color) {\n        return this.set('color', color);\n    }\n\n    /**\n     * A representation of a cue point.\n     *\n     * @typedef {Object} VimeoCuePoint\n     * @property {number} time The time of the cue point.\n     * @property {object} data The data passed when adding the cue point.\n     * @property {string} id The unique id for use with removeCuePoint.\n     */\n    /**\n     * A promise to get the cue points of a video.\n     *\n     * @promise GetCuePointsPromise\n     * @fulfill {VimeoCuePoint[]} The cue points added to the video.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Get an array of the cue points added to the video.\n     *\n     * @return {GetCuePointsPromise}\n     */\n    getCuePoints() {\n        return this.get('cuePoints');\n    }\n\n    /**\n     * A promise to get the current time of the video.\n     *\n     * @promise GetCurrentTimePromise\n     * @fulfill {number} The current time in seconds.\n     */\n    /**\n     * Get the current playback position in seconds.\n     *\n     * @return {GetCurrentTimePromise}\n     */\n    getCurrentTime() {\n        return this.get('currentTime');\n    }\n\n    /**\n     * A promise to set the current time of the video.\n     *\n     * @promise SetCurrentTimePromise\n     * @fulfill {number} The actual current time that was set.\n     * @reject {RangeError} the time was less than 0 or greater than the\n     *         video’s duration.\n     */\n    /**\n     * Set the current playback position in seconds. If the player was\n     * paused, it will remain paused. Likewise, if the player was playing,\n     * it will resume playing once the video has buffered.\n     *\n     * You can provide an accurate time and the player will attempt to seek\n     * to as close to that time as possible. The exact time will be the\n     * fulfilled value of the promise.\n     *\n     * @param {number} currentTime\n     * @return {SetCurrentTimePromise}\n     */\n    setCurrentTime(currentTime) {\n        return this.set('currentTime', currentTime);\n    }\n\n    /**\n     * A promise to get the duration of the video.\n     *\n     * @promise GetDurationPromise\n     * @fulfill {number} The duration in seconds.\n     */\n    /**\n     * Get the duration of the video in seconds. It will be rounded to the\n     * nearest second before playback begins, and to the nearest thousandth\n     * of a second after playback begins.\n     *\n     * @return {GetDurationPromise}\n     */\n    getDuration() {\n        return this.get('duration');\n    }\n\n    /**\n     * A promise to get the ended state of the video.\n     *\n     * @promise GetEndedPromise\n     * @fulfill {boolean} Whether or not the video has ended.\n     */\n    /**\n     * Get the ended state of the video. The video has ended if\n     * `currentTime === duration`.\n     *\n     * @return {GetEndedPromise}\n     */\n    getEnded() {\n        return this.get('ended');\n    }\n\n    /**\n     * A promise to get the loop state of the player.\n     *\n     * @promise GetLoopPromise\n     * @fulfill {boolean} Whether or not the player is set to loop.\n     */\n    /**\n     * Get the loop state of the player.\n     *\n     * @return {GetLoopPromise}\n     */\n    getLoop() {\n        return this.get('loop');\n    }\n\n    /**\n     * A promise to set the loop state of the player.\n     *\n     * @promise SetLoopPromise\n     * @fulfill {boolean} The loop state that was set.\n     */\n    /**\n     * Set the loop state of the player. When set to `true`, the player\n     * will start over immediately once playback ends.\n     *\n     * @param {boolean} loop\n     * @return {SetLoopPromise}\n     */\n    setLoop(loop) {\n        return this.set('loop', loop);\n    }\n\n    /**\n     * A promise to get the paused state of the player.\n     *\n     * @promise GetLoopPromise\n     * @fulfill {boolean} Whether or not the video is paused.\n     */\n    /**\n     * Get the paused state of the player.\n     *\n     * @return {GetLoopPromise}\n     */\n    getPaused() {\n        return this.get('paused');\n    }\n\n    /**\n     * A promise to get the playback rate of the player.\n     *\n     * @promise GetPlaybackRatePromise\n     * @fulfill {number} The playback rate of the player on a scale from 0.5 to 2.\n     */\n    /**\n     * Get the playback rate of the player on a scale from `0.5` to `2`.\n     *\n     * @return {GetPlaybackRatePromise}\n     */\n    getPlaybackRate() {\n        return this.get('playbackRate');\n    }\n\n    /**\n     * A promise to set the playbackrate of the player.\n     *\n     * @promise SetPlaybackRatePromise\n     * @fulfill {number} The playback rate was set.\n     * @reject {RangeError} The playback rate was less than 0.5 or greater than 2.\n     */\n    /**\n     * Set the playback rate of the player on a scale from `0.5` to `2`. When set\n     * via the API, the playback rate will not be synchronized to other\n     * players or stored as the viewer's preference.\n     *\n     * @param {number} playbackRate\n     * @return {SetPlaybackRatePromise}\n     */\n    setPlaybackRate(playbackRate) {\n        return this.set('playbackRate', playbackRate);\n    }\n\n    /**\n     * A promise to get the text tracks of a video.\n     *\n     * @promise GetTextTracksPromise\n     * @fulfill {VimeoTextTrack[]} The text tracks associated with the video.\n     */\n    /**\n     * Get an array of the text tracks that exist for the video.\n     *\n     * @return {GetTextTracksPromise}\n     */\n    getTextTracks() {\n        return this.get('textTracks');\n    }\n\n    /**\n     * A promise to get the embed code for the video.\n     *\n     * @promise GetVideoEmbedCodePromise\n     * @fulfill {string} The `<iframe>` embed code for the video.\n     */\n    /**\n     * Get the `<iframe>` embed code for the video.\n     *\n     * @return {GetVideoEmbedCodePromise}\n     */\n    getVideoEmbedCode() {\n        return this.get('videoEmbedCode');\n    }\n\n    /**\n     * A promise to get the id of the video.\n     *\n     * @promise GetVideoIdPromise\n     * @fulfill {number} The id of the video.\n     */\n    /**\n     * Get the id of the video.\n     *\n     * @return {GetVideoIdPromise}\n     */\n    getVideoId() {\n        return this.get('videoId');\n    }\n\n    /**\n     * A promise to get the title of the video.\n     *\n     * @promise GetVideoTitlePromise\n     * @fulfill {number} The title of the video.\n     */\n    /**\n     * Get the title of the video.\n     *\n     * @return {GetVideoTitlePromise}\n     */\n    getVideoTitle() {\n        return this.get('videoTitle');\n    }\n\n    /**\n     * A promise to get the native width of the video.\n     *\n     * @promise GetVideoWidthPromise\n     * @fulfill {number} The native width of the video.\n     */\n    /**\n     * Get the native width of the currently‐playing video. The width of\n     * the highest‐resolution available will be used before playback begins.\n     *\n     * @return {GetVideoWidthPromise}\n     */\n    getVideoWidth() {\n        return this.get('videoWidth');\n    }\n\n    /**\n     * A promise to get the native height of the video.\n     *\n     * @promise GetVideoHeightPromise\n     * @fulfill {number} The native height of the video.\n     */\n    /**\n     * Get the native height of the currently‐playing video. The height of\n     * the highest‐resolution available will be used before playback begins.\n     *\n     * @return {GetVideoHeightPromise}\n     */\n    getVideoHeight() {\n        return this.get('videoHeight');\n    }\n\n    /**\n     * A promise to get the vimeo.com url for the video.\n     *\n     * @promise GetVideoUrlPromise\n     * @fulfill {number} The vimeo.com url for the video.\n     * @reject {PrivacyError} The url isn’t available because of the video’s privacy setting.\n     */\n    /**\n     * Get the vimeo.com url for the video.\n     *\n     * @return {GetVideoUrlPromise}\n     */\n    getVideoUrl() {\n        return this.get('videoUrl');\n    }\n\n    /**\n     * A promise to get the volume level of the player.\n     *\n     * @promise GetVolumePromise\n     * @fulfill {number} The volume level of the player on a scale from 0 to 1.\n     */\n    /**\n     * Get the current volume level of the player on a scale from `0` to `1`.\n     *\n     * Most mobile devices do not support an independent volume from the\n     * system volume. In those cases, this method will always return `1`.\n     *\n     * @return {GetVolumePromise}\n     */\n    getVolume() {\n        return this.get('volume');\n    }\n\n    /**\n     * A promise to set the volume level of the player.\n     *\n     * @promise SetVolumePromise\n     * @fulfill {number} The volume was set.\n     * @reject {RangeError} The volume was less than 0 or greater than 1.\n     */\n    /**\n     * Set the volume of the player on a scale from `0` to `1`. When set\n     * via the API, the volume level will not be synchronized to other\n     * players or stored as the viewer’s preference.\n     *\n     * Most mobile devices do not support setting the volume. An error will\n     * *not* be triggered in that situation.\n     *\n     * @param {number} volume\n     * @return {SetVolumePromise}\n     */\n    setVolume(volume) {\n        return this.set('volume', volume);\n    }\n}\n\n// Setup embed only if this is not a node environment\n// and if there is no existing Vimeo Player object\nif (!isNode && (window.Vimeo && !window.Vimeo.Player)) {\n    initializeEmbeds();\n    resizeEmbeds();\n}\n\nexport default Player;\n"]}